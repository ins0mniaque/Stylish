using System.Globalization;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;

using Microsoft.CSharp;

namespace Stylish;

public static class SegoeSymbolGenerator
{
    public static async Task < IReadOnlyCollection < SegoeSymbolData > > Generate ( SegoeSymbolDataSource dataSource, string destination, CancellationToken cancellationToken = default )
    {
        ArgumentNullException.ThrowIfNull ( dataSource );

        var symbols = new Dictionary < int, SegoeSymbolData > ( );

        using var fluentSource = dataSource.OpenFluent ( );
        using var mdl2Source   = dataSource.OpenMDL2   ( );

        await foreach ( var fluent in SegoeSymbolData.Parse ( fluentSource, cancellationToken ) )
            AddSymbol ( fluent );

        await foreach ( var mdl2 in SegoeSymbolData.Parse ( mdl2Source, cancellationToken ) )
            AddSymbol ( mdl2 );

        using var fluentSymbolFile = File.CreateText ( Path.Combine ( destination, "SegoeSymbol.cs" ) );

        await fluentSymbolFile.GenerateHeader  ( "Segoe Fluent Icons", cancellationToken ).ConfigureAwait ( false );
        await fluentSymbolFile.GenerateSymbols ( symbols.Values,       cancellationToken ).ConfigureAwait ( false );

        return symbols.Values.ToArray ( );

        void AddSymbol ( SegoeSymbolData symbol )
        {
            symbol = FixData ( symbol );

            if ( ! symbols.TryGetValue ( symbol.Value, out var existingSymbol ) || existingSymbol.Name.Length < symbol.Name.Length )
                symbols [ symbol.Value ] = symbol;
        }
    }

    private static async Task GenerateHeader ( this TextWriter destination, string summary, CancellationToken cancellationToken )
    {
        await WriteLine ( "// <auto-generated />" );
        await WriteLine ( "namespace Stylish.Symbols;" );
        await WriteLine ( );

        await WriteLine ( "/// <summary>" );
        await WriteLine ( "/// {0}", summary );
        await WriteLine ( "/// </summary>" );
        await WriteLine ( "/// <remarks>" );
        await WriteLine ( "/// Reference: <see href=\"{1}\">{0}</see>", SegoeSymbolDataSource.Reference.Name, SegoeSymbolDataSource.Reference.Uri );
        await WriteLine ( "/// </remarks>" );

        ConfiguredTaskAwaitable WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        }
    }

    private static async Task GenerateSymbols ( this TextWriter destination, IReadOnlyCollection < SegoeSymbolData > symbols, CancellationToken cancellationToken )
    {
        await WriteLine ( "public enum SegoeSymbol" );
        await WriteLine ( "{{" );
        await WriteLine ( "    None," );

        foreach ( var symbol in symbols.OrderBy ( symbol => symbol.Value ) )
        {
            await WriteLine ( );
            await WriteLine ( "    /// <summary>{0}: \\u{1:X4}</summary>", FormatSummary ( symbol.Name ), symbol.Value );
            await WriteLine ( "    {0} = 0x{1:X4},", CreateIdentifier ( symbol.Name ), symbol.Value );
        }

        await destination.WriteAsync ( "}".AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        await destination.FlushAsync ( cancellationToken )                  .ConfigureAwait ( false );

        ConfiguredTaskAwaitable WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        }
    }

    private static SegoeSymbolData FixData ( SegoeSymbolData symbol )
    {
        if ( symbol.Name.StartsWith ( "Mob", StringComparison.Ordinal ) && ! symbol.Name.StartsWith ( "Mobile", StringComparison.Ordinal ) )
            return symbol with { Name = "Mobile" + symbol.Name [ 3.. ] };

        if ( symbol.Name.StartsWith ( "Instert", StringComparison.Ordinal ) )
            return symbol with { Name = "Insert" + symbol.Name [ 7.. ] };

        if ( symbol.Name == "StockDown" && symbol.Value is 0xEB11 )
            return symbol with { Name = "StockUp" };

        return symbol;
    }

    private static string FormatSummary ( string name )
    {
        return SecurityElement.Escape ( name );
    }

    private static readonly CSharpCodeProvider codeProvider = new ( );

    private static string CreateIdentifier ( string name )
    {
        return codeProvider.CreateValidIdentifier ( RemoveDiacritics ( name ) );
    }

    private static string RemoveDiacritics ( string text ) => string.Concat    ( text.Normalize ( NormalizationForm.FormD )
                                                                                     .Where     ( c => CharUnicodeInfo.GetUnicodeCategory ( c ) is not UnicodeCategory.NonSpacingMark ) )
                                                                    .Normalize ( NormalizationForm.FormC );
}