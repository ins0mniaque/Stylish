using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Security;
using System.Text;

using Microsoft.CSharp;

namespace Stylish.Unicode;

[ SuppressMessage ( "Reliability", "CA2007:Consider calling ConfigureAwait on the awaited task", Justification = "<Pending>" ) ]
public static class EmojiGenerator
{
    public static async Task<UnicodeEmoji [ ]> Generate(string destination, double unicodeVersion = UnicodeEmoji.LatestVersion, double emojiVersion = UnicodeEmoji.LatestVersion, CancellationToken cancellationToken = default )
    {
        var emojis = new Dictionary < string, UnicodeEmoji > ( 4096 );

        await foreach (var emoji in UnicodeEmoji.Download(unicodeVersion, cancellationToken))
            if ( emoji.Version <= emojiVersion )
                if ( ! emojis.TryGetValue ( emoji.Name, out var existing ) || existing.Value.Length > emoji.Value.Length )
                    emojis [ emoji.Name ] = emoji;

        using var emojiFile = File.CreateText ( Path.Combine ( destination, "Emoji.cs" ) );

        await emojiFile.GenerateHeader ( "Emoji list", emojiVersion, cancellationToken );

        var generated = await emojiFile.GenerateEmojis(emojis.Values, cancellationToken);

        var versions  = generated.ToLookup(e => e.Version).OrderBy ( g => g.Key ).ToList ( );
        var groups    = generated.ToLookup(e => e.Group).OrderBy ( g => g.Key ).ToList ( );
        var subgroups = generated.ToLookup(e => e.Subgroup).OrderBy ( g => g.Key ).ToList ( );

        using var emojiGroupFile = File.CreateText ( Path.Combine ( destination, "EmojiGroup.cs" ) );

        await emojiGroupFile.GenerateHeader ( "Emoji groups", emojiVersion, cancellationToken );
        await emojiGroupFile.GenerateEnum ( "EmojiGroup", FormatGroupSummary, groups, cancellationToken );

        using var emojiSubgroupFile = File.CreateText ( Path.Combine ( destination, "EmojiSubgroup.cs" ) );

        await emojiSubgroupFile.GenerateHeader ( "Emoji subgroups", emojiVersion, cancellationToken );
        await emojiSubgroupFile.GenerateEnum ( "EmojiSubgroup", FormatSubgroupSummary, subgroups, cancellationToken );

        using var emojiMetadataFile = File.CreateText ( Path.Combine ( destination, "EmojiMetadata.cs" ) );

        await emojiMetadataFile.GenerateHeader ( "Emoji metadata", emojiVersion, cancellationToken );

        await emojiMetadataFile.GenerateMetadata(versions, groups, subgroups, cancellationToken);

        return generated;
    }

    private static async Task GenerateHeader(this TextWriter destination, string summary, double unicodeVersion, CancellationToken cancellationToken)
    {
        await WriteLine("// <auto-generated />");
        await WriteLine("namespace Stylish.Unicode;");
        await WriteLine();

        await WriteLine("/// <summary>");
        await WriteLine("/// {0} (Unicode {1:0.0})", summary, unicodeVersion);
        await WriteLine("/// </summary>");
        await WriteLine("/// <remarks>");
        await WriteLine("/// Source: {0}", UnicodeEmoji.GetSourceUri(unicodeVersion));
        await WriteLine("/// </remarks>");
        await WriteLine();

        Task WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken );
        }
    }

    private static async Task<UnicodeEmoji[]> GenerateEmojis(this TextWriter destination, IReadOnlyCollection<UnicodeEmoji> emojis, CancellationToken cancellationToken)
    {
        await WriteLine("public enum Emoji : long");
        await WriteLine("{{");
        await WriteLine("    None,");

        var generated = new List < UnicodeEmoji > ( );
        var lastGroup = string.Empty;
        var lastEmoji = (UnicodeEmoji?) null;

        foreach (var emoji in emojis)
        {
            if ( EmojiEncoding.Encode(emoji.Value) is not { } code )
                throw new InvalidOperationException ( $"{emoji.Name}: {emoji.Value} (Length: {emoji.Value.Length}) failed to encode." );

            var decoded = EmojiEncoding.Decode (code);

            if ( decoded != EmojiEncoding.SetVariant ( emoji.Value, Variant.None ) )
                throw new InvalidOperationException ( $"{emoji.Name}: {emoji.Value} (Length: { emoji.Value.Length}) failed to decode. Decoded to { decoded } (Length: {decoded.Length})." );

            if (emoji.Group != lastGroup)
            {
                if ( lastEmoji is not null )
                    await WriteLine("    #endregion {0}", lastGroup);

                lastGroup = emoji.Group;

                await WriteLine();
                await WriteLine("    #region {0}", emoji.Group);
                await WriteLine();
            }

            await WriteLine("    /// <summary>{0}: {1} (Unicode {2:0.0})</summary>", FormatNameSummary(emoji.Name), emoji.Value, emoji.Version);
            await WriteLine("    {0} = unchecked ( (long) 0x{1:X8} ),",CreateIdentifier(emoji.Name), unchecked((ulong)code));
            await WriteLine();

            generated.Add ( lastEmoji = emoji );
        }

        if ( lastEmoji is not null )
            await WriteLine($"    #endregion {lastGroup}");

        await destination.WriteAsync ( "}".AsMemory ( ), cancellationToken );
        await destination.FlushAsync ( );

        return generated.ToArray ( );

        Task WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken );
        }
    }

    private static async Task GenerateEnum ( this TextWriter destination, string name, Func<string,string> formatSummary, IReadOnlyList < IGrouping < string, UnicodeEmoji > > versions, CancellationToken cancellationToken)
    {
        await WriteLine("public enum {0}", name);
        await WriteLine("{{");

        await WriteLine("    None,");
        await WriteLine();

        var last = versions [ ^1 ];

        foreach (var version in versions.SkipLast ( 1 ) )
        {
            await WriteLine("    /// <summary>{0} ({1})</summary>", formatSummary(version.Key), FormatEmojiCount ( version.Count ( ) ) );
            await WriteLine("    {0},", CreateIdentifier(version.Key) );
            await WriteLine();
        }

        await WriteLine("    /// <summary>{0} ({1})</summary>", formatSummary(last.Key), FormatEmojiCount ( last.Count ( ) ) );
        await WriteLine("    {0}", CreateIdentifier(last.Key) );

        await destination.WriteAsync ( "}".AsMemory ( ), cancellationToken );
        await destination.FlushAsync ( );

        Task WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken );
        }
    }

    private static async Task GenerateMetadata(this TextWriter destination, IReadOnlyList < IGrouping < double, UnicodeEmoji > > versions, IReadOnlyList < IGrouping < string, UnicodeEmoji > > groups, IReadOnlyList < IGrouping < string, UnicodeEmoji > > subgroups, CancellationToken cancellationToken)
    {
        await WriteLine("public static class EmojiMetadata");
        await WriteLine("{{");

        await destination.GenerateMetadataMethod ( versions, "double GetVersion", "{0:0.0}", FormatVersionRegion, "double.NaN", cancellationToken );

        await WriteLine ( );

        await destination.GenerateMetadataMethod ( groups, "EmojiGroup GetGroup", "EmojiGroup.{0}", FormatGroupRegion, "EmojiGroup.None", cancellationToken );

        await WriteLine ( );

        await destination.GenerateMetadataMethod ( subgroups, "EmojiSubgroup GetSubgroup", "EmojiSubgroup.{0}", FormatSubgroupRegion, "EmojiSubgroup.None", cancellationToken );

        await destination.WriteAsync ( "}".AsMemory ( ), cancellationToken );
        await destination.FlushAsync ( );

        Task WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken );
        }
    }

    private static async Task GenerateMetadataMethod < T > ( this TextWriter destination, IReadOnlyList < IGrouping < T, UnicodeEmoji > > versions, string sig, string a, Func<T,string> formatRegion, string defaultValue, CancellationToken cancellationToken) where T : notnull
    {
        await WriteLine("    public static {0} ( this Emoji emoji ) => emoji switch", sig);
        await WriteLine("    {{");

        var first = true;

        foreach (var version in versions)
        {
            if ( ! first )
                await WriteLine();

            first = false;

            var region = formatRegion ( version.Key );
            var last = version.Last ( );

            await WriteLine("        #region {0}", region );
            await WriteLine();

            foreach (var emoji in version.SkipLast ( 1 ) )
            {
                await WriteLine("        Emoji.{0} or", CreateIdentifier(emoji.Name) );
            }

            await WriteLine("        Emoji.{0} => {1},", CreateIdentifier(last.Name), string.Format ( CultureInfo.InvariantCulture, a, version.Key is string key ? CreateIdentifier ( key ) : version.Key ) );
            await WriteLine();
            await WriteLine("        #endregion {0}", region );
        }

        await WriteLine ( );
        await WriteLine ("        _ => {0}", defaultValue );

        await WriteLine ( "    }};" );

        Task WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken );
        }
    }

    private static string FormatEmojiCount ( int count )
    {
        return string.Format ( CultureInfo.InvariantCulture, count > 1 ? "{0} emojis" : "{0} emojis", count );
    }

    private static string FormatNameSummary ( string name )
    {
        name = SecurityElement.Escape ( name );

        var colon = name.IndexOf ( ':', StringComparison.Ordinal );
        if ( colon >= 0 )
            return name [ ..colon ] + $" <i>({ name [ (colon + 2).. ] })</i>";

        return name;
    }

    private static string FormatGroupSummary ( string name )
    {
        return SecurityElement.Escape ( name );
    }

    private static string FormatSubgroupSummary ( string name )
    {
        name = name.Replace("alphanum",  "Alphanumeric", StringComparison.Ordinal)
                   .Replace("skin-tone", "Skin tone",    StringComparison.Ordinal);

        var dash = name.IndexOf ( '-', StringComparison.Ordinal );
        if ( dash >= 0 )
            return SecurityElement.Escape ( ToTitleCase ( name [ ..dash ] ) ) + $" <i>({ SecurityElement.Escape ( name [ (dash + 1).. ].Replace ( '-', ' ' ) ) })</i>";

        return SecurityElement.Escape ( ToTitleCase ( name ) );
    }

    private static string FormatGroupRegion ( string name )
    {
        return name;
    }

    private static string FormatSubgroupRegion ( string name )
    {
        name = name.Replace("alphanum",  "Alphanumeric", StringComparison.Ordinal)
                   .Replace("skin-tone", "Skin tone",    StringComparison.Ordinal);

        var dash = name.IndexOf ( '-', StringComparison.Ordinal );
        if ( dash >= 0 )
            return ToTitleCase ( name [ ..dash ] ) + $" ({ name [ (dash + 1).. ].Replace ( '-', ' ' ) })";

        return ToTitleCase ( name );
    }

    private static string FormatVersionRegion ( double version )
    {
        return string.Format ( CultureInfo.InvariantCulture, "Version {0:0.0}", version );
    }

    private static CSharpCodeProvider CSharpCode { get; } = new ( );
    private static readonly char [ ] wordSeparators = new[] { ' ', '-', ',', '’', '!', '“', '”', '(', ')', '.' };

    private static string CreateIdentifier ( string name )
    {
        var identifier = new StringBuilder ( name );

        identifier.Replace(':', '_');
        identifier.Replace("&", "And");
        identifier.Replace("#", "NumberSign");
        identifier.Replace("*", "Asterisk");
        identifier.Replace("alphanum", "Alphanumeric");
        identifier.Replace("1st", "First");
        identifier.Replace("2nd", "Second");
        identifier.Replace("3rd", "Third");
        identifier.Replace("’s", string.Empty);

        var words = identifier.ToString ( )
                       .Split(wordSeparators, StringSplitOptions.RemoveEmptyEntries)
                       .Select(ToTitleCase);

        return CSharpCode.CreateValidIdentifier ( RemoveDiacritics ( string.Concat ( words ) ) );
    }

    private static string ToTitleCase ( string text ) => CultureInfo.InvariantCulture.TextInfo.ToTitleCase ( text );

    private static string RemoveDiacritics ( string text ) => string.Concat(text.Normalize(NormalizationForm.FormD)
                                                                                .Where(c => CharUnicodeInfo.GetUnicodeCategory(c) != UnicodeCategory.NonSpacingMark))
                                                                    .Normalize(NormalizationForm.FormC);
}