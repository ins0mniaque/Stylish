using System.Globalization;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;

using Microsoft.CSharp;

namespace Stylish.Unicode;

public static class EmojiGenerator
{
    public static async Task < IReadOnlyCollection < UnicodeEmoji > > Generate ( string destination, double unicodeVersion = UnicodeEmoji.LatestVersion, double emojiVersion = UnicodeEmoji.LatestVersion, CancellationToken cancellationToken = default )
    {
        var emojis = new Dictionary < string, UnicodeEmoji > ( 4096 );

        await foreach ( var emoji in UnicodeEmoji.Download ( unicodeVersion, cancellationToken ) )
            if ( emoji.Version <= emojiVersion )
                if ( ! emojis.TryGetValue ( emoji.Name, out var existing ) || existing.Value.Length > emoji.Value.Length )
                    emojis [ emoji.Name ] = emoji;

        using var emojiFile = File.CreateText ( Path.Combine ( destination, "Emoji.cs" ) );

        await emojiFile.GenerateHeader ( "Emoji list", emojiVersion, cancellationToken ).ConfigureAwait ( false );
        await emojiFile.GenerateEmojis ( emojis.Values,              cancellationToken ).ConfigureAwait ( false );

        var versions  = emojis.Values.ToLookup ( emoji => emoji.Version  ).OrderBy ( lookup => lookup.Key ).ToList ( );
        var groups    = emojis.Values.ToLookup ( emoji => emoji.Group    ).OrderBy ( lookup => lookup.Key ).ToList ( );
        var subgroups = emojis.Values.ToLookup ( emoji => emoji.Subgroup ).OrderBy ( lookup => lookup.Key ).ToList ( );

        using var emojiGroupFile = File.CreateText ( Path.Combine ( destination, "EmojiGroup.cs" ) );

        await emojiGroupFile.GenerateHeader ( "Emoji groups", emojiVersion,             cancellationToken ).ConfigureAwait ( false );
        await emojiGroupFile.GenerateEnum   ( "EmojiGroup", FormatGroupSummary, groups, cancellationToken ).ConfigureAwait ( false );

        using var emojiSubgroupFile = File.CreateText ( Path.Combine ( destination, "EmojiSubgroup.cs" ) );

        await emojiSubgroupFile.GenerateHeader ( "Emoji subgroups", emojiVersion,                   cancellationToken ).ConfigureAwait ( false );
        await emojiSubgroupFile.GenerateEnum   ( "EmojiSubgroup", FormatSubgroupSummary, subgroups, cancellationToken ).ConfigureAwait ( false );

        using var emojiMetadataFile = File.CreateText ( Path.Combine ( destination, "EmojiMetadata.cs" ) );

        await emojiMetadataFile.GenerateHeader   ( "Emoji metadata", emojiVersion, cancellationToken ).ConfigureAwait ( false );
        await emojiMetadataFile.GenerateMetadata ( versions, groups, subgroups,    cancellationToken ).ConfigureAwait ( false );

        return emojis.Values;
    }

    private static async Task GenerateHeader ( this TextWriter destination, string summary, double unicodeVersion, CancellationToken cancellationToken )
    {
        await WriteLine ( "// <auto-generated />" );
        await WriteLine ( "namespace Stylish.Unicode;" );
        await WriteLine ( );

        await WriteLine ( "/// <summary>" );
        await WriteLine ( "/// {0} (Unicode {1:0.0})", summary, unicodeVersion );
        await WriteLine ( "/// </summary>" );
        await WriteLine ( "/// <remarks>" );
        await WriteLine ( "/// Source: {0}", UnicodeEmoji.GetSourceUri ( unicodeVersion ) );
        await WriteLine ( "/// </remarks>" );
        await WriteLine ( );

        ConfiguredTaskAwaitable WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        }
    }

    private static async Task GenerateEmojis ( this TextWriter destination, IReadOnlyCollection < UnicodeEmoji > emojis, CancellationToken cancellationToken )
    {
        await WriteLine ( "public enum Emoji : long" );
        await WriteLine ( "{{" );
        await WriteLine ( "    None," );

        var lastGroup = string.Empty;
        var lastEmoji = (UnicodeEmoji?) null;

        foreach ( var emoji in emojis )
        {
            if ( EmojiEncoding.Encode ( emoji.Value ) is not { } code )
                throw new InvalidOperationException ( $"{ emoji.Name }: { emoji.Value } (Length: { emoji.Value.Length }) failed to encode." );

            var decoded = EmojiEncoding.Decode ( code );
            if ( decoded != EmojiEncoding.SetVariant ( emoji.Value, Variant.None ) )
                throw new InvalidOperationException ( $"{ emoji.Name }: { emoji.Value } (Length: { emoji.Value.Length }) failed to decode. Decoded as { decoded } (Length: { decoded.Length })." );

            if ( emoji.Group != lastGroup )
            {
                if ( lastEmoji is not null )
                    await WriteLine ( "    #endregion {0}", lastGroup );

                lastGroup = emoji.Group;

                await WriteLine ( );
                await WriteLine ( "    #region {0}", emoji.Group );
                await WriteLine ( );
            }

            await WriteLine ( "    /// <summary>{0}: {1} (Unicode {2:0.0})</summary>", FormatNameSummary ( emoji.Name ), emoji.Value, emoji.Version );
            await WriteLine ( "    {0} = unchecked ( (long) 0x{1:X8} ),",              CreateIdentifier  ( emoji.Name ), unchecked ( (ulong) code ) );
            await WriteLine ( );

            lastEmoji = emoji;
        }

        if ( lastEmoji is not null )
            await WriteLine ( "    #endregion {0}", lastGroup );

        await destination.WriteAsync ( "}".AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        await destination.FlushAsync ( cancellationToken )                  .ConfigureAwait ( false );

        ConfiguredTaskAwaitable WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        }
    }

    private static async Task GenerateEnum ( this TextWriter destination, string name, Func < string, string > formatSummary, IReadOnlyList < IGrouping < string, UnicodeEmoji > > groups, CancellationToken cancellationToken )
    {
        await WriteLine ( "public enum {0}", name );
        await WriteLine ( "{{" );

        await WriteLine ( "    None," );
        await WriteLine ( );

        var last = groups [ ^1 ];

        foreach (var group in groups.SkipLast ( 1 ) )
        {
            await WriteLine ( "    /// <summary>{0} ({1})</summary>", formatSummary    ( group.Key ), FormatEmojiCount ( group.Count ( ) ) );
            await WriteLine ( "    {0},",                             CreateIdentifier ( group.Key ) );
            await WriteLine ( );
        }

        await WriteLine ( "    /// <summary>{0} ({1})</summary>", formatSummary    ( last.Key ), FormatEmojiCount ( last.Count ( ) ) );
        await WriteLine ( "    {0}",                              CreateIdentifier ( last.Key ) );

        await destination.WriteAsync ( "}".AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        await destination.FlushAsync ( cancellationToken )                  .ConfigureAwait ( false );

        ConfiguredTaskAwaitable WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        }
    }

    private static async Task GenerateMetadata ( this TextWriter destination, IReadOnlyList < IGrouping < double, UnicodeEmoji > > versions, IReadOnlyList < IGrouping < string, UnicodeEmoji > > groups, IReadOnlyList < IGrouping < string, UnicodeEmoji > > subgroups, CancellationToken cancellationToken )
    {
        await WriteLine ( "public static class EmojiMetadata" );
        await WriteLine ( "{{" );

        await destination.GenerateMetadataMethod ( versions, "double GetVersion", "{0:0.0}", FormatVersionRegion, "double.NaN", cancellationToken ).ConfigureAwait ( false );

        await WriteLine ( );

        await destination.GenerateMetadataMethod ( groups, "EmojiGroup GetGroup", "EmojiGroup.{0}", FormatGroupRegion, "EmojiGroup.None", cancellationToken ).ConfigureAwait ( false );

        await WriteLine ( );

        await destination.GenerateMetadataMethod ( subgroups, "EmojiSubgroup GetSubgroup", "EmojiSubgroup.{0}", FormatSubgroupRegion, "EmojiSubgroup.None", cancellationToken ).ConfigureAwait ( false );

        await destination.WriteAsync ( "}".AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        await destination.FlushAsync ( cancellationToken )                  .ConfigureAwait ( false );

        ConfiguredTaskAwaitable WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        }
    }

    private static async Task GenerateMetadataMethod < T > ( this TextWriter destination, IReadOnlyList < IGrouping < T, UnicodeEmoji > > groups, string signature, string valueFormat, Func < T, string > formatRegion, string defaultValue, CancellationToken cancellationToken ) where T : notnull
    {
        await WriteLine ( "    public static {0} ( this Emoji emoji ) => emoji switch", signature );
        await WriteLine ( "    {{" );

        var isFirstGroup = true;

        foreach ( var group in groups )
        {
            if ( ! isFirstGroup )
                await WriteLine ( );

            isFirstGroup = false;

            var region    = formatRegion ( group.Key );
            var lastEmoji = group.Last ( );

            await WriteLine ( "        #region {0}", region );
            await WriteLine ( );

            foreach ( var emoji in group.SkipLast ( 1 ) )
                await WriteLine ( "        Emoji.{0} or", CreateIdentifier ( emoji.Name ) );

            await WriteLine ( "        Emoji.{0} => {1},", CreateIdentifier ( lastEmoji.Name ), string.Format ( CultureInfo.InvariantCulture, valueFormat, group.Key is string key ? CreateIdentifier ( key ) : group.Key ) );
            await WriteLine ( );
            await WriteLine ( "        #endregion {0}", region );
        }

        await WriteLine ( );
        await WriteLine ("        _ => {0}", defaultValue );

        await WriteLine ( "    }};" );

        ConfiguredTaskAwaitable WriteLine ( string? format = null, params object [  ] args )
        {
            return destination.WriteLineAsync ( string.Format ( CultureInfo.InvariantCulture, format ?? string.Empty, args ).AsMemory ( ), cancellationToken ).ConfigureAwait ( false );
        }
    }

    private static string FormatEmojiCount ( int count )
    {
        return string.Format ( CultureInfo.InvariantCulture, count > 1 ? "{0} emojis" : "{0} emojis", count );
    }

    private static string FormatNameSummary ( string name )
    {
        name = SecurityElement.Escape ( name );

        var colon = name.IndexOf ( ':', StringComparison.Ordinal );
        if ( colon >= 0 )
            return name [ ..colon ] + $" <i>({ name [ (colon + 2).. ] })</i>";

        return name;
    }

    private static string FormatGroupSummary ( string group )
    {
        return SecurityElement.Escape ( group );
    }

    private static string FormatSubgroupSummary ( string subgroup )
    {
        subgroup = subgroup.Replace ( "alphanum",  "Alphanumeric", StringComparison.Ordinal )
                           .Replace ( "skin-tone", "Skin tone",    StringComparison.Ordinal );

        var dash = subgroup.IndexOf ( '-', StringComparison.Ordinal );
        if ( dash >= 0 )
            return SecurityElement.Escape ( ToTitleCase ( subgroup [ ..dash ] ) ) + $" <i>({ SecurityElement.Escape ( subgroup [ ( dash + 1 ).. ].Replace ( '-', ' ' ) ) })</i>";

        return SecurityElement.Escape ( ToTitleCase ( subgroup ) );
    }

    private static string FormatGroupRegion ( string group )
    {
        return group;
    }

    private static string FormatSubgroupRegion ( string subgroup )
    {
        subgroup = subgroup.Replace ( "alphanum",  "Alphanumeric", StringComparison.Ordinal )
                           .Replace ( "skin-tone", "Skin tone",    StringComparison.Ordinal );

        var dash = subgroup.IndexOf ( '-', StringComparison.Ordinal );
        if ( dash >= 0 )
            return ToTitleCase ( subgroup [ ..dash ] ) + $" ({ subgroup [ ( dash + 1 ).. ].Replace ( '-', ' ' ) })";

        return ToTitleCase ( subgroup );
    }

    private static string FormatVersionRegion ( double version )
    {
        return string.Format ( CultureInfo.InvariantCulture, "Version {0:0.0}", version );
    }

    private static readonly CSharpCodeProvider codeProvider   = new ( );
    private static readonly char [ ]           wordSeparators = [ ' ', '-', ',', '’', '!', '“', '”', '(', ')', '.' ];

    private static string CreateIdentifier ( string name )
    {
        var identifier = new StringBuilder ( name );

        identifier.Replace ( ':',  '_'          );
        identifier.Replace ( "&",  "And"        );
        identifier.Replace ( "#",  "NumberSign" );
        identifier.Replace ( "*",  "Asterisk"   );
        identifier.Replace ( "’s", string.Empty );

        identifier.Replace ( "alphanum", "Alphanumeric" );
        identifier.Replace ( "1st",      "First"  );
        identifier.Replace ( "2nd",      "Second" );
        identifier.Replace ( "3rd",      "Third"  );

        var words = identifier.ToString ( )
                              .Split    ( wordSeparators, StringSplitOptions.RemoveEmptyEntries )
                              .Select   ( ToTitleCase );

        return codeProvider.CreateValidIdentifier ( RemoveDiacritics ( string.Concat ( words ) ) );
    }

    private static string ToTitleCase      ( string text ) => CultureInfo.InvariantCulture.TextInfo.ToTitleCase ( text );
    private static string RemoveDiacritics ( string text ) => string.Concat    ( text.Normalize ( NormalizationForm.FormD )
                                                                                     .Where     ( c => CharUnicodeInfo.GetUnicodeCategory ( c ) is not UnicodeCategory.NonSpacingMark ) )
                                                                    .Normalize ( NormalizationForm.FormC );
}